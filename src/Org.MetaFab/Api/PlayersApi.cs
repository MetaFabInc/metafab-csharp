/*
 * MetaFab API
 *
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.4.1
 * Contact: metafabproject@gmail.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using RestSharp;
using Org.MetaFab.Client;
using Org.MetaFab.Model;

namespace Org.MetaFab.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlayersApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Authenticate player
        /// </summary>
        /// <remarks>
        /// Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <returns>AuthPlayer200Response</returns>
        AuthPlayer200Response AuthPlayer (string xGameKey);

        /// <summary>
        /// Authenticate player
        /// </summary>
        /// <remarks>
        /// Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <returns>ApiResponse of AuthPlayer200Response</returns>
        ApiResponse<AuthPlayer200Response> AuthPlayerWithHttpInfo (string xGameKey);
        /// <summary>
        /// Create player
        /// </summary>
        /// <remarks>
        /// Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <returns>AuthPlayer200Response</returns>
        AuthPlayer200Response CreatePlayer (string xGameKey, CreatePlayerRequest createPlayerRequest);

        /// <summary>
        /// Create player
        /// </summary>
        /// <remarks>
        /// Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <returns>ApiResponse of AuthPlayer200Response</returns>
        ApiResponse<AuthPlayer200Response> CreatePlayerWithHttpInfo (string xGameKey, CreatePlayerRequest createPlayerRequest);
        /// <summary>
        /// Get player
        /// </summary>
        /// <remarks>
        /// Returns a player object for the provided player id.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>PublicPlayer</returns>
        PublicPlayer GetPlayer (string playerId);

        /// <summary>
        /// Get player
        /// </summary>
        /// <remarks>
        /// Returns a player object for the provided player id.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>ApiResponse of PublicPlayer</returns>
        ApiResponse<PublicPlayer> GetPlayerWithHttpInfo (string playerId);
        /// <summary>
        /// Get player data
        /// </summary>
        /// <remarks>
        /// Returns the latest public and protected data as an object for the provided playerId.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>GetPlayerData200Response</returns>
        GetPlayerData200Response GetPlayerData (string playerId);

        /// <summary>
        /// Get player data
        /// </summary>
        /// <remarks>
        /// Returns the latest public and protected data as an object for the provided playerId.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>ApiResponse of GetPlayerData200Response</returns>
        ApiResponse<GetPlayerData200Response> GetPlayerDataWithHttpInfo (string playerId);
        /// <summary>
        /// Get players
        /// </summary>
        /// <remarks>
        /// Returns all players for the authenticated game as an array of player objects.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <returns>List<PublicPlayer></returns>
        List<PublicPlayer> GetPlayers (string xAuthorization);

        /// <summary>
        /// Get players
        /// </summary>
        /// <remarks>
        /// Returns all players for the authenticated game as an array of player objects.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <returns>ApiResponse of List<PublicPlayer></returns>
        ApiResponse<List<PublicPlayer>> GetPlayersWithHttpInfo (string xAuthorization);
        /// <summary>
        /// Remove player connected wallet
        /// </summary>
        /// <remarks>
        /// Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <returns></returns>
        void RemovePlayerConnectedWallet (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest);

        /// <summary>
        /// Remove player connected wallet
        /// </summary>
        /// <remarks>
        /// Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemovePlayerConnectedWalletWithHttpInfo (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest);
        /// <summary>
        /// Set player connected wallet
        /// </summary>
        /// <remarks>
        /// Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <returns>SetPlayerConnectedWallet200Response</returns>
        SetPlayerConnectedWallet200Response SetPlayerConnectedWallet (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest);

        /// <summary>
        /// Set player connected wallet
        /// </summary>
        /// <remarks>
        /// Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <returns>ApiResponse of SetPlayerConnectedWallet200Response</returns>
        ApiResponse<SetPlayerConnectedWallet200Response> SetPlayerConnectedWalletWithHttpInfo (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest);
        /// <summary>
        /// Set player data
        /// </summary>
        /// <remarks>
        /// Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <returns>GetPlayerData200Response</returns>
        GetPlayerData200Response SetPlayerData (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest);

        /// <summary>
        /// Set player data
        /// </summary>
        /// <remarks>
        /// Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <returns>ApiResponse of GetPlayerData200Response</returns>
        ApiResponse<GetPlayerData200Response> SetPlayerDataWithHttpInfo (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest);
        /// <summary>
        /// Update player
        /// </summary>
        /// <remarks>
        /// Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <returns>PlayerModel</returns>
        PlayerModel UpdatePlayer (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest);

        /// <summary>
        /// Update player
        /// </summary>
        /// <remarks>
        /// Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <returns>ApiResponse of PlayerModel</returns>
        ApiResponse<PlayerModel> UpdatePlayerWithHttpInfo (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Authenticate player
        /// </summary>
        /// <remarks>
        /// Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of AuthPlayer200Response</returns>
        System.Threading.Tasks.Task<AuthPlayer200Response> AuthPlayerAsync (string xGameKey, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Authenticate player
        /// </summary>
        /// <remarks>
        /// Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (AuthPlayer200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthPlayer200Response>> AuthPlayerWithHttpInfoAsync (string xGameKey, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Create player
        /// </summary>
        /// <remarks>
        /// Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of AuthPlayer200Response</returns>
        System.Threading.Tasks.Task<AuthPlayer200Response> CreatePlayerAsync (string xGameKey, CreatePlayerRequest createPlayerRequest, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create player
        /// </summary>
        /// <remarks>
        /// Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (AuthPlayer200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuthPlayer200Response>> CreatePlayerWithHttpInfoAsync (string xGameKey, CreatePlayerRequest createPlayerRequest, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get player
        /// </summary>
        /// <remarks>
        /// Returns a player object for the provided player id.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of PublicPlayer</returns>
        System.Threading.Tasks.Task<PublicPlayer> GetPlayerAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get player
        /// </summary>
        /// <remarks>
        /// Returns a player object for the provided player id.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (PublicPlayer)</returns>
        System.Threading.Tasks.Task<ApiResponse<PublicPlayer>> GetPlayerWithHttpInfoAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get player data
        /// </summary>
        /// <remarks>
        /// Returns the latest public and protected data as an object for the provided playerId.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of GetPlayerData200Response</returns>
        System.Threading.Tasks.Task<GetPlayerData200Response> GetPlayerDataAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get player data
        /// </summary>
        /// <remarks>
        /// Returns the latest public and protected data as an object for the provided playerId.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (GetPlayerData200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetPlayerData200Response>> GetPlayerDataWithHttpInfoAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get players
        /// </summary>
        /// <remarks>
        /// Returns all players for the authenticated game as an array of player objects.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of List<PublicPlayer></returns>
        System.Threading.Tasks.Task<List<PublicPlayer>> GetPlayersAsync (string xAuthorization, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get players
        /// </summary>
        /// <remarks>
        /// Returns all players for the authenticated game as an array of player objects.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (List&lt;PublicPlayer&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PublicPlayer>>> GetPlayersWithHttpInfoAsync (string xAuthorization, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Remove player connected wallet
        /// </summary>
        /// <remarks>
        /// Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemovePlayerConnectedWalletAsync (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Remove player connected wallet
        /// </summary>
        /// <remarks>
        /// Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemovePlayerConnectedWalletWithHttpInfoAsync (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Set player connected wallet
        /// </summary>
        /// <remarks>
        /// Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of SetPlayerConnectedWallet200Response</returns>
        System.Threading.Tasks.Task<SetPlayerConnectedWallet200Response> SetPlayerConnectedWalletAsync (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Set player connected wallet
        /// </summary>
        /// <remarks>
        /// Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (SetPlayerConnectedWallet200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SetPlayerConnectedWallet200Response>> SetPlayerConnectedWalletWithHttpInfoAsync (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Set player data
        /// </summary>
        /// <remarks>
        /// Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of GetPlayerData200Response</returns>
        System.Threading.Tasks.Task<GetPlayerData200Response> SetPlayerDataAsync (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Set player data
        /// </summary>
        /// <remarks>
        /// Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (GetPlayerData200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetPlayerData200Response>> SetPlayerDataWithHttpInfoAsync (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Update player
        /// </summary>
        /// <remarks>
        /// Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of PlayerModel</returns>
        System.Threading.Tasks.Task<PlayerModel> UpdatePlayerAsync (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update player
        /// </summary>
        /// <remarks>
        /// Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </remarks>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (PlayerModel)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlayerModel>> UpdatePlayerWithHttpInfoAsync (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest, CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PlayersApi : IPlayersApi
    {
        private Org.MetaFab.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayersApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PlayersApi(String basePath)
        {
            this.Configuration = new Org.MetaFab.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Org.MetaFab.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayersApi"/> class
        /// </summary>
        /// <returns></returns>
        public PlayersApi()
        {
            this.Configuration = Org.MetaFab.Client.Configuration.Default;

            ExceptionFactory = Org.MetaFab.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayersApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PlayersApi(Org.MetaFab.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Org.MetaFab.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Org.MetaFab.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.MetaFab.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.MetaFab.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Authenticate player Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <returns>AuthPlayer200Response</returns>
        public AuthPlayer200Response AuthPlayer (string xGameKey)
        {
             ApiResponse<AuthPlayer200Response> localVarResponse = AuthPlayerWithHttpInfo(xGameKey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Authenticate player Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <returns>ApiResponse of AuthPlayer200Response</returns>
        public ApiResponse<AuthPlayer200Response> AuthPlayerWithHttpInfo (string xGameKey)
        {
            // verify the required parameter 'xGameKey' is set
            if (xGameKey == null)
                throw new ApiException(400, "Missing required parameter 'xGameKey' when calling PlayersApi->AuthPlayer");

            var localVarPath = "/v1/players/auth";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (xGameKey != null) localVarHeaderParams.Add("X-Game-Key", this.Configuration.ApiClient.ParameterToString(xGameKey)); // header parameter

            // authentication (basicAuth) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AuthPlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AuthPlayer200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AuthPlayer200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AuthPlayer200Response)));
        }

        /// <summary>
        /// Authenticate player Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of AuthPlayer200Response</returns>
        public async System.Threading.Tasks.Task<AuthPlayer200Response> AuthPlayerAsync (string xGameKey, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<AuthPlayer200Response> localVarResponse = await AuthPlayerWithHttpInfoAsync(xGameKey, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Authenticate player Returns an existing player object containing access token, wallet, and other details for a game when provided a valid username and password login using Basic Auth.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (AuthPlayer200Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AuthPlayer200Response>> AuthPlayerWithHttpInfoAsync (string xGameKey, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'xGameKey' is set
            if (xGameKey == null)
                throw new ApiException(400, "Missing required parameter 'xGameKey' when calling PlayersApi->AuthPlayer");

            var localVarPath = "/v1/players/auth";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (xGameKey != null) localVarHeaderParams.Add("X-Game-Key", this.Configuration.ApiClient.ParameterToString(xGameKey)); // header parameter

            // authentication (basicAuth) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AuthPlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AuthPlayer200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AuthPlayer200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AuthPlayer200Response)));
        }

        /// <summary>
        /// Create player Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <returns>AuthPlayer200Response</returns>
        public AuthPlayer200Response CreatePlayer (string xGameKey, CreatePlayerRequest createPlayerRequest)
        {
             ApiResponse<AuthPlayer200Response> localVarResponse = CreatePlayerWithHttpInfo(xGameKey, createPlayerRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create player Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <returns>ApiResponse of AuthPlayer200Response</returns>
        public ApiResponse<AuthPlayer200Response> CreatePlayerWithHttpInfo (string xGameKey, CreatePlayerRequest createPlayerRequest)
        {
            // verify the required parameter 'xGameKey' is set
            if (xGameKey == null)
                throw new ApiException(400, "Missing required parameter 'xGameKey' when calling PlayersApi->CreatePlayer");
            // verify the required parameter 'createPlayerRequest' is set
            if (createPlayerRequest == null)
                throw new ApiException(400, "Missing required parameter 'createPlayerRequest' when calling PlayersApi->CreatePlayer");

            var localVarPath = "/v1/players";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (xGameKey != null) localVarHeaderParams.Add("X-Game-Key", this.Configuration.ApiClient.ParameterToString(xGameKey)); // header parameter
            if (createPlayerRequest != null && createPlayerRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(createPlayerRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = createPlayerRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreatePlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AuthPlayer200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AuthPlayer200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AuthPlayer200Response)));
        }

        /// <summary>
        /// Create player Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of AuthPlayer200Response</returns>
        public async System.Threading.Tasks.Task<AuthPlayer200Response> CreatePlayerAsync (string xGameKey, CreatePlayerRequest createPlayerRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<AuthPlayer200Response> localVarResponse = await CreatePlayerWithHttpInfoAsync(xGameKey, createPlayerRequest, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create player Create a new player for a game. Players are automatically associated with an internally managed wallet.  Player access tokens can be used to directly interact with any MetaFab managed contracts, currencies, items collections, marketplaces and more. Player interactions are also gasless by default, completely removing all crypto friction for players to engage with your MetaFab supported games.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xGameKey">The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.</param>
        /// <param name="createPlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (AuthPlayer200Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AuthPlayer200Response>> CreatePlayerWithHttpInfoAsync (string xGameKey, CreatePlayerRequest createPlayerRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'xGameKey' is set
            if (xGameKey == null)
                throw new ApiException(400, "Missing required parameter 'xGameKey' when calling PlayersApi->CreatePlayer");
            // verify the required parameter 'createPlayerRequest' is set
            if (createPlayerRequest == null)
                throw new ApiException(400, "Missing required parameter 'createPlayerRequest' when calling PlayersApi->CreatePlayer");

            var localVarPath = "/v1/players";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (xGameKey != null) localVarHeaderParams.Add("X-Game-Key", this.Configuration.ApiClient.ParameterToString(xGameKey)); // header parameter
            if (createPlayerRequest != null && createPlayerRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(createPlayerRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = createPlayerRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreatePlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AuthPlayer200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AuthPlayer200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AuthPlayer200Response)));
        }

        /// <summary>
        /// Get player Returns a player object for the provided player id.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>PublicPlayer</returns>
        public PublicPlayer GetPlayer (string playerId)
        {
             ApiResponse<PublicPlayer> localVarResponse = GetPlayerWithHttpInfo(playerId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get player Returns a player object for the provided player id.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>ApiResponse of PublicPlayer</returns>
        public ApiResponse<PublicPlayer> GetPlayerWithHttpInfo (string playerId)
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->GetPlayer");

            var localVarPath = "/v1/players/{playerId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PublicPlayer>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PublicPlayer) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PublicPlayer)));
        }

        /// <summary>
        /// Get player Returns a player object for the provided player id.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of PublicPlayer</returns>
        public async System.Threading.Tasks.Task<PublicPlayer> GetPlayerAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<PublicPlayer> localVarResponse = await GetPlayerWithHttpInfoAsync(playerId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get player Returns a player object for the provided player id.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (PublicPlayer)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PublicPlayer>> GetPlayerWithHttpInfoAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->GetPlayer");

            var localVarPath = "/v1/players/{playerId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PublicPlayer>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PublicPlayer) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PublicPlayer)));
        }

        /// <summary>
        /// Get player data Returns the latest public and protected data as an object for the provided playerId.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>GetPlayerData200Response</returns>
        public GetPlayerData200Response GetPlayerData (string playerId)
        {
             ApiResponse<GetPlayerData200Response> localVarResponse = GetPlayerDataWithHttpInfo(playerId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get player data Returns the latest public and protected data as an object for the provided playerId.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <returns>ApiResponse of GetPlayerData200Response</returns>
        public ApiResponse<GetPlayerData200Response> GetPlayerDataWithHttpInfo (string playerId)
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->GetPlayerData");

            var localVarPath = "/v1/players/{playerId}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPlayerData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetPlayerData200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (GetPlayerData200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetPlayerData200Response)));
        }

        /// <summary>
        /// Get player data Returns the latest public and protected data as an object for the provided playerId.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of GetPlayerData200Response</returns>
        public async System.Threading.Tasks.Task<GetPlayerData200Response> GetPlayerDataAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<GetPlayerData200Response> localVarResponse = await GetPlayerDataWithHttpInfoAsync(playerId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get player data Returns the latest public and protected data as an object for the provided playerId.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (GetPlayerData200Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GetPlayerData200Response>> GetPlayerDataWithHttpInfoAsync (string playerId, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->GetPlayerData");

            var localVarPath = "/v1/players/{playerId}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPlayerData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetPlayerData200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (GetPlayerData200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetPlayerData200Response)));
        }

        /// <summary>
        /// Get players Returns all players for the authenticated game as an array of player objects.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <returns>List<PublicPlayer></returns>
        public List<PublicPlayer> GetPlayers (string xAuthorization)
        {
             ApiResponse<List<PublicPlayer>> localVarResponse = GetPlayersWithHttpInfo(xAuthorization);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get players Returns all players for the authenticated game as an array of player objects.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <returns>ApiResponse of List<PublicPlayer></returns>
        public ApiResponse<List<PublicPlayer>> GetPlayersWithHttpInfo (string xAuthorization)
        {
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->GetPlayers");

            var localVarPath = "/v1/players";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPlayers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<PublicPlayer>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<PublicPlayer>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<PublicPlayer>)));
        }

        /// <summary>
        /// Get players Returns all players for the authenticated game as an array of player objects.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of List<PublicPlayer></returns>
        public async System.Threading.Tasks.Task<List<PublicPlayer>> GetPlayersAsync (string xAuthorization, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<List<PublicPlayer>> localVarResponse = await GetPlayersWithHttpInfoAsync(xAuthorization, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get players Returns all players for the authenticated game as an array of player objects.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of the authenticating game.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (List&lt;PublicPlayer&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<PublicPlayer>>> GetPlayersWithHttpInfoAsync (string xAuthorization, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->GetPlayers");

            var localVarPath = "/v1/players";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPlayers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<PublicPlayer>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<PublicPlayer>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<PublicPlayer>)));
        }

        /// <summary>
        /// Remove player connected wallet Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <returns></returns>
        public void RemovePlayerConnectedWallet (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest)
        {
             RemovePlayerConnectedWalletWithHttpInfo(playerId, playerWalletId, removePlayerConnectedWalletRequest);
        }

        /// <summary>
        /// Remove player connected wallet Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemovePlayerConnectedWalletWithHttpInfo (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest)
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->RemovePlayerConnectedWallet");
            // verify the required parameter 'playerWalletId' is set
            if (playerWalletId == null)
                throw new ApiException(400, "Missing required parameter 'playerWalletId' when calling PlayersApi->RemovePlayerConnectedWallet");
            // verify the required parameter 'removePlayerConnectedWalletRequest' is set
            if (removePlayerConnectedWalletRequest == null)
                throw new ApiException(400, "Missing required parameter 'removePlayerConnectedWalletRequest' when calling PlayersApi->RemovePlayerConnectedWallet");

            var localVarPath = "/v1/players/{playerId}/wallets/{playerWalletId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (playerWalletId != null) localVarPathParams.Add("playerWalletId", this.Configuration.ApiClient.ParameterToString(playerWalletId)); // path parameter
            if (removePlayerConnectedWalletRequest != null && removePlayerConnectedWalletRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(removePlayerConnectedWalletRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = removePlayerConnectedWalletRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemovePlayerConnectedWallet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove player connected wallet Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemovePlayerConnectedWalletAsync (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
             await RemovePlayerConnectedWalletWithHttpInfoAsync(playerId, playerWalletId, removePlayerConnectedWalletRequest, cancellationToken);

        }

        /// <summary>
        /// Remove player connected wallet Removes an external wallet from a player account. The player's wallet is reverted to their custodial wallet.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="playerWalletId">Any player wallet id within the MetaFab ecosystem.</param>
        /// <param name="removePlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemovePlayerConnectedWalletWithHttpInfoAsync (string playerId, string playerWalletId, RemovePlayerConnectedWalletRequest removePlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->RemovePlayerConnectedWallet");
            // verify the required parameter 'playerWalletId' is set
            if (playerWalletId == null)
                throw new ApiException(400, "Missing required parameter 'playerWalletId' when calling PlayersApi->RemovePlayerConnectedWallet");
            // verify the required parameter 'removePlayerConnectedWalletRequest' is set
            if (removePlayerConnectedWalletRequest == null)
                throw new ApiException(400, "Missing required parameter 'removePlayerConnectedWalletRequest' when calling PlayersApi->RemovePlayerConnectedWallet");

            var localVarPath = "/v1/players/{playerId}/wallets/{playerWalletId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (playerWalletId != null) localVarPathParams.Add("playerWalletId", this.Configuration.ApiClient.ParameterToString(playerWalletId)); // path parameter
            if (removePlayerConnectedWalletRequest != null && removePlayerConnectedWalletRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(removePlayerConnectedWalletRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = removePlayerConnectedWalletRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemovePlayerConnectedWallet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Set player connected wallet Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <returns>SetPlayerConnectedWallet200Response</returns>
        public SetPlayerConnectedWallet200Response SetPlayerConnectedWallet (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest)
        {
             ApiResponse<SetPlayerConnectedWallet200Response> localVarResponse = SetPlayerConnectedWalletWithHttpInfo(playerId, xAuthorization, setPlayerConnectedWalletRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Set player connected wallet Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <returns>ApiResponse of SetPlayerConnectedWallet200Response</returns>
        public ApiResponse<SetPlayerConnectedWallet200Response> SetPlayerConnectedWalletWithHttpInfo (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest)
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->SetPlayerConnectedWallet");
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->SetPlayerConnectedWallet");
            // verify the required parameter 'setPlayerConnectedWalletRequest' is set
            if (setPlayerConnectedWalletRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPlayerConnectedWalletRequest' when calling PlayersApi->SetPlayerConnectedWallet");

            var localVarPath = "/v1/players/{playerId}/wallets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter
            if (setPlayerConnectedWalletRequest != null && setPlayerConnectedWalletRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPlayerConnectedWalletRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPlayerConnectedWalletRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPlayerConnectedWallet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SetPlayerConnectedWallet200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SetPlayerConnectedWallet200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SetPlayerConnectedWallet200Response)));
        }

        /// <summary>
        /// Set player connected wallet Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of SetPlayerConnectedWallet200Response</returns>
        public async System.Threading.Tasks.Task<SetPlayerConnectedWallet200Response> SetPlayerConnectedWalletAsync (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<SetPlayerConnectedWallet200Response> localVarResponse = await SetPlayerConnectedWalletWithHttpInfoAsync(playerId, xAuthorization, setPlayerConnectedWalletRequest, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Set player connected wallet Sets an external wallet as the wallet for a player account. The set wallet can transact gaslessly with all MetaFab related systems through the same MetaFab API calls as custodial wallets without requiring transaction signing or private keys.  This is done through an internal system MetaFab has created that allows an external connected wallet to delegate transaction signing for a specific game's set of contracts to a player's password protected custodial wallet. This allow the custodial wallet to sign and submit transactions to a specific game's related contracts as if they were signed and submitted by the connected external wallet. This also means that all earned tokens, purchased items and any interactions happen and are recorded on chain as the external connected wallet. No additional logic needs to be writted by developers to support both custodial and external wallets, everything just works.  Finally, this endpoint is meant for advanced users. The majority of developers who want to implement external wallet support for their game can do so without any extra work through our whitelabeled wallet connection feature that implements this endpoint underneath the hood without any required work.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="setPlayerConnectedWalletRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (SetPlayerConnectedWallet200Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SetPlayerConnectedWallet200Response>> SetPlayerConnectedWalletWithHttpInfoAsync (string playerId, string xAuthorization, SetPlayerConnectedWalletRequest setPlayerConnectedWalletRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->SetPlayerConnectedWallet");
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->SetPlayerConnectedWallet");
            // verify the required parameter 'setPlayerConnectedWalletRequest' is set
            if (setPlayerConnectedWalletRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPlayerConnectedWalletRequest' when calling PlayersApi->SetPlayerConnectedWallet");

            var localVarPath = "/v1/players/{playerId}/wallets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter
            if (setPlayerConnectedWalletRequest != null && setPlayerConnectedWalletRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPlayerConnectedWalletRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPlayerConnectedWalletRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPlayerConnectedWallet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SetPlayerConnectedWallet200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SetPlayerConnectedWallet200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SetPlayerConnectedWallet200Response)));
        }

        /// <summary>
        /// Set player data Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <returns>GetPlayerData200Response</returns>
        public GetPlayerData200Response SetPlayerData (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest)
        {
             ApiResponse<GetPlayerData200Response> localVarResponse = SetPlayerDataWithHttpInfo(playerId, xAuthorization, setPlayerDataRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Set player data Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <returns>ApiResponse of GetPlayerData200Response</returns>
        public ApiResponse<GetPlayerData200Response> SetPlayerDataWithHttpInfo (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest)
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->SetPlayerData");
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->SetPlayerData");
            // verify the required parameter 'setPlayerDataRequest' is set
            if (setPlayerDataRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPlayerDataRequest' when calling PlayersApi->SetPlayerData");

            var localVarPath = "/v1/players/{playerId}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter
            if (setPlayerDataRequest != null && setPlayerDataRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPlayerDataRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPlayerDataRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPlayerData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetPlayerData200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (GetPlayerData200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetPlayerData200Response)));
        }

        /// <summary>
        /// Set player data Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of GetPlayerData200Response</returns>
        public async System.Threading.Tasks.Task<GetPlayerData200Response> SetPlayerDataAsync (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<GetPlayerData200Response> localVarResponse = await SetPlayerDataWithHttpInfoAsync(playerId, xAuthorization, setPlayerDataRequest, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Set player data Creates or updates public and/or protected data for the provided playerId. Data updates are performed using deep merging. This means that when you update any top level or nested properties specific to player public or protected data, you only need to include the properties you are making changes to. Any existing properties not included in request body arguments will be retained on the player data object.  Please note, When writing an array type for a player, arrays do not follow the deep merge approach. If you add or remove an item from an array, the entire array must be passed as an argument when updating the related property for player public or protected data.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.</param>
        /// <param name="setPlayerDataRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (GetPlayerData200Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GetPlayerData200Response>> SetPlayerDataWithHttpInfoAsync (string playerId, string xAuthorization, SetPlayerDataRequest setPlayerDataRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->SetPlayerData");
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->SetPlayerData");
            // verify the required parameter 'setPlayerDataRequest' is set
            if (setPlayerDataRequest == null)
                throw new ApiException(400, "Missing required parameter 'setPlayerDataRequest' when calling PlayersApi->SetPlayerData");

            var localVarPath = "/v1/players/{playerId}/data";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter
            if (setPlayerDataRequest != null && setPlayerDataRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(setPlayerDataRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = setPlayerDataRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPlayerData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<GetPlayerData200Response>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (GetPlayerData200Response) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(GetPlayerData200Response)));
        }

        /// <summary>
        /// Update player Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <returns>PlayerModel</returns>
        public PlayerModel UpdatePlayer (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest)
        {
             ApiResponse<PlayerModel> localVarResponse = UpdatePlayerWithHttpInfo(playerId, xAuthorization, updatePlayerRequest);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update player Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <returns>ApiResponse of PlayerModel</returns>
        public ApiResponse<PlayerModel> UpdatePlayerWithHttpInfo (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest)
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->UpdatePlayer");
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->UpdatePlayer");
            // verify the required parameter 'updatePlayerRequest' is set
            if (updatePlayerRequest == null)
                throw new ApiException(400, "Missing required parameter 'updatePlayerRequest' when calling PlayersApi->UpdatePlayer");

            var localVarPath = "/v1/players/{playerId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter
            if (updatePlayerRequest != null && updatePlayerRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(updatePlayerRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = updatePlayerRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdatePlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PlayerModel>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PlayerModel) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PlayerModel)));
        }

        /// <summary>
        /// Update player Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of PlayerModel</returns>
        public async System.Threading.Tasks.Task<PlayerModel> UpdatePlayerAsync (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<PlayerModel> localVarResponse = await UpdatePlayerWithHttpInfoAsync(playerId, xAuthorization, updatePlayerRequest, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update player Update various fields specific to a player. Such as changing its password and resetting its access token.
        /// </summary>
        /// <exception cref="Org.MetaFab.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerId">Any player id within the MetaFab ecosystem.</param>
        /// <param name="xAuthorization">The &#x60;accessToken&#x60; of the authenticating player.</param>
        /// <param name="updatePlayerRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (PlayerModel)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PlayerModel>> UpdatePlayerWithHttpInfoAsync (string playerId, string xAuthorization, UpdatePlayerRequest updatePlayerRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'playerId' is set
            if (playerId == null)
                throw new ApiException(400, "Missing required parameter 'playerId' when calling PlayersApi->UpdatePlayer");
            // verify the required parameter 'xAuthorization' is set
            if (xAuthorization == null)
                throw new ApiException(400, "Missing required parameter 'xAuthorization' when calling PlayersApi->UpdatePlayer");
            // verify the required parameter 'updatePlayerRequest' is set
            if (updatePlayerRequest == null)
                throw new ApiException(400, "Missing required parameter 'updatePlayerRequest' when calling PlayersApi->UpdatePlayer");

            var localVarPath = "/v1/players/{playerId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (playerId != null) localVarPathParams.Add("playerId", this.Configuration.ApiClient.ParameterToString(playerId)); // path parameter
            if (xAuthorization != null) localVarHeaderParams.Add("X-Authorization", this.Configuration.ApiClient.ParameterToString(xAuthorization)); // header parameter
            if (updatePlayerRequest != null && updatePlayerRequest.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(updatePlayerRequest); // http body (model) parameter
            }
            else
            {
                localVarPostBody = updatePlayerRequest; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdatePlayer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PlayerModel>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PlayerModel) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PlayerModel)));
        }

    }
}
