/*
 * MetaFab API
 *
 * Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.5.1
 * Contact: metafabproject@gmail.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.MetaFab.Client.OpenAPIDateConverter;

namespace Org.MetaFab.Model
{
    /// <summary>
    /// SetPlayerDataRequest
    /// </summary>
    [DataContract]
    public partial class SetPlayerDataRequest :  IEquatable<SetPlayerDataRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SetPlayerDataRequest" /> class.
        /// </summary>
        /// <param name="protectedData">protectedData can only be set if &#x60;X-Authorization&#x60; includes credentials for the game the target player is a part of. Expects an arbitrary object allowed to contain any set of properties and nested data within those properties, including arrays.  protectedData is great for storing sensitive player data like tracking experience points, off-chain inventories, save states, and more - things that players shouldn&#39;t have the ability to directly change themselves..</param>
        /// <param name="publicData">publicData can be set if &#x60;X-Authorization&#x60; includes credentials for the target player or game the player is a part of. Expects an arbitrary object allowed to contain any set of properties and nested data within those properties, including arrays.  publicData is great for storing player preferences like in-game settings, non-sensitive data and more. Anything that a player should have the ability to directly change themselves without client or server verification can be stored in publicData..</param>
        public SetPlayerDataRequest(Object protectedData = default(Object), Object publicData = default(Object))
        {
            this.ProtectedData = protectedData;
            this.PublicData = publicData;
        }

        /// <summary>
        /// protectedData can only be set if &#x60;X-Authorization&#x60; includes credentials for the game the target player is a part of. Expects an arbitrary object allowed to contain any set of properties and nested data within those properties, including arrays.  protectedData is great for storing sensitive player data like tracking experience points, off-chain inventories, save states, and more - things that players shouldn&#39;t have the ability to directly change themselves.
        /// </summary>
        /// <value>protectedData can only be set if &#x60;X-Authorization&#x60; includes credentials for the game the target player is a part of. Expects an arbitrary object allowed to contain any set of properties and nested data within those properties, including arrays.  protectedData is great for storing sensitive player data like tracking experience points, off-chain inventories, save states, and more - things that players shouldn&#39;t have the ability to directly change themselves.</value>
        [DataMember(Name="protectedData", EmitDefaultValue=false)]
        public Object ProtectedData { get; set; }

        /// <summary>
        /// publicData can be set if &#x60;X-Authorization&#x60; includes credentials for the target player or game the player is a part of. Expects an arbitrary object allowed to contain any set of properties and nested data within those properties, including arrays.  publicData is great for storing player preferences like in-game settings, non-sensitive data and more. Anything that a player should have the ability to directly change themselves without client or server verification can be stored in publicData.
        /// </summary>
        /// <value>publicData can be set if &#x60;X-Authorization&#x60; includes credentials for the target player or game the player is a part of. Expects an arbitrary object allowed to contain any set of properties and nested data within those properties, including arrays.  publicData is great for storing player preferences like in-game settings, non-sensitive data and more. Anything that a player should have the ability to directly change themselves without client or server verification can be stored in publicData.</value>
        [DataMember(Name="publicData", EmitDefaultValue=false)]
        public Object PublicData { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SetPlayerDataRequest {\n");
            sb.Append("  ProtectedData: ").Append(ProtectedData).Append("\n");
            sb.Append("  PublicData: ").Append(PublicData).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SetPlayerDataRequest);
        }

        /// <summary>
        /// Returns true if SetPlayerDataRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of SetPlayerDataRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SetPlayerDataRequest input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ProtectedData == input.ProtectedData ||
                    (this.ProtectedData != null &&
                    this.ProtectedData.Equals(input.ProtectedData))
                ) && 
                (
                    this.PublicData == input.PublicData ||
                    (this.PublicData != null &&
                    this.PublicData.Equals(input.PublicData))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ProtectedData != null)
                    hashCode = hashCode * 59 + this.ProtectedData.GetHashCode();
                if (this.PublicData != null)
                    hashCode = hashCode * 59 + this.PublicData.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
