/*
 * MetaFab API
 *
 *  Complete MetaFab API references and guides can be found at: https://trymetafab.com
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: metafabproject@gmail.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.MetaFab.Client.OpenAPIDateConverter;

namespace Org.MetaFab.Model
{
    /// <summary>
    /// SetLootboxManagerLootboxRequest
    /// </summary>
    [DataContract]
    public partial class SetLootboxManagerLootboxRequest :  IEquatable<SetLootboxManagerLootboxRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SetLootboxManagerLootboxRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected SetLootboxManagerLootboxRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="SetLootboxManagerLootboxRequest" /> class.
        /// </summary>
        /// <param name="id">A unique lootbox id to use for this lootbox for the lootbox manager. If an existing lootbox id is used, the current lootbox will be updated but the existing number of opens will be kept. If you want to reset the number of opens for an existing lootbox, first remove it using the remove lootbox endpoint, then set it. (required).</param>
        /// <param name="inputCollectionAddress">A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for input items required by this lootbox. &#x60;inputCollectionAddress&#x60; or &#x60;inputCollectionId&#x60; can optionally be provided..</param>
        /// <param name="inputCollectionId">A valid MetaFab collection id that represents the collection for input items required by this lootbox. &#x60;inputCollectionAddress&#x60; or &#x60;inputCollectionId&#x60; can optionally be provided..</param>
        /// <param name="inputCollectionItemIds">An array of item ids from the provided input collection that are required to open this lootbox. Input items are burn upon opening a lootbox..</param>
        /// <param name="inputCollectionItemAmounts">An array of amounts for each item id from the provided input collection that are required to open this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index..</param>
        /// <param name="outputCollectionAddress">A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for possible output items given by this lootbox. &#x60;outputCollectionAddress&#x60; or &#x60;outputCollectionId&#x60; can optionally be provided..</param>
        /// <param name="outputCollectionId">A valid MetaFab collection id that represents the collection for possible output items given by this lootbox. &#x60;outputCollectionAddress&#x60; or &#x60;outputCollectionId&#x60; can optionally be provided..</param>
        /// <param name="outputCollectionItemIds">An array of item ids from the provided output collection that are possibly given by this lootbox. Randomly selected output items are automatically minted if the lootbox manager contract has the &#x60;minter&#x60; role for the output collection contract. Otherwise, they are transferred from the item balance held by the lootbox manager contract..</param>
        /// <param name="outputCollectionItemAmounts">An array of amounts for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index..</param>
        /// <param name="outputCollectionItemWeights">An array of weights for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Any positive integer for an item&#39;s weight can be provided. The weight for an item relative to the sum of all possible item weights determines the probability that an item will be picked upon a lootbox being opened. Item weights array indices are reflective of the probability weight for a given item id at the same index..</param>
        /// <param name="outputTotalItems">The number of items randomly selected from the possible output items when this lootbox is open. If you provide a value greater than 1, it is possible for the same item to be selected more than once, giving the opener more than one of that item&#39;s output from the lootbox..</param>
        public SetLootboxManagerLootboxRequest(int id = default(int), string inputCollectionAddress = default(string), string inputCollectionId = default(string), List<int> inputCollectionItemIds = default(List<int>), List<int> inputCollectionItemAmounts = default(List<int>), string outputCollectionAddress = default(string), string outputCollectionId = default(string), List<int> outputCollectionItemIds = default(List<int>), List<int> outputCollectionItemAmounts = default(List<int>), List<int> outputCollectionItemWeights = default(List<int>), int outputTotalItems = default(int))
        {
            // to ensure "id" is required (not null)
            if (id == null)
            {
                throw new InvalidDataException("id is a required property for SetLootboxManagerLootboxRequest and cannot be null");
            }
            else
            {
                this.Id = id;
            }

            this.InputCollectionAddress = inputCollectionAddress;
            this.InputCollectionId = inputCollectionId;
            this.InputCollectionItemIds = inputCollectionItemIds;
            this.InputCollectionItemAmounts = inputCollectionItemAmounts;
            this.OutputCollectionAddress = outputCollectionAddress;
            this.OutputCollectionId = outputCollectionId;
            this.OutputCollectionItemIds = outputCollectionItemIds;
            this.OutputCollectionItemAmounts = outputCollectionItemAmounts;
            this.OutputCollectionItemWeights = outputCollectionItemWeights;
            this.OutputTotalItems = outputTotalItems;
        }

        /// <summary>
        /// A unique lootbox id to use for this lootbox for the lootbox manager. If an existing lootbox id is used, the current lootbox will be updated but the existing number of opens will be kept. If you want to reset the number of opens for an existing lootbox, first remove it using the remove lootbox endpoint, then set it.
        /// </summary>
        /// <value>A unique lootbox id to use for this lootbox for the lootbox manager. If an existing lootbox id is used, the current lootbox will be updated but the existing number of opens will be kept. If you want to reset the number of opens for an existing lootbox, first remove it using the remove lootbox endpoint, then set it.</value>
        [DataMember(Name="id", EmitDefaultValue=true)]
        public int Id { get; set; }

        /// <summary>
        /// A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for input items required by this lootbox. &#x60;inputCollectionAddress&#x60; or &#x60;inputCollectionId&#x60; can optionally be provided.
        /// </summary>
        /// <value>A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for input items required by this lootbox. &#x60;inputCollectionAddress&#x60; or &#x60;inputCollectionId&#x60; can optionally be provided.</value>
        [DataMember(Name="inputCollectionAddress", EmitDefaultValue=false)]
        public string InputCollectionAddress { get; set; }

        /// <summary>
        /// A valid MetaFab collection id that represents the collection for input items required by this lootbox. &#x60;inputCollectionAddress&#x60; or &#x60;inputCollectionId&#x60; can optionally be provided.
        /// </summary>
        /// <value>A valid MetaFab collection id that represents the collection for input items required by this lootbox. &#x60;inputCollectionAddress&#x60; or &#x60;inputCollectionId&#x60; can optionally be provided.</value>
        [DataMember(Name="inputCollectionId", EmitDefaultValue=false)]
        public string InputCollectionId { get; set; }

        /// <summary>
        /// An array of item ids from the provided input collection that are required to open this lootbox. Input items are burn upon opening a lootbox.
        /// </summary>
        /// <value>An array of item ids from the provided input collection that are required to open this lootbox. Input items are burn upon opening a lootbox.</value>
        [DataMember(Name="inputCollectionItemIds", EmitDefaultValue=false)]
        public List<int> InputCollectionItemIds { get; set; }

        /// <summary>
        /// An array of amounts for each item id from the provided input collection that are required to open this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index.
        /// </summary>
        /// <value>An array of amounts for each item id from the provided input collection that are required to open this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index.</value>
        [DataMember(Name="inputCollectionItemAmounts", EmitDefaultValue=false)]
        public List<int> InputCollectionItemAmounts { get; set; }

        /// <summary>
        /// A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for possible output items given by this lootbox. &#x60;outputCollectionAddress&#x60; or &#x60;outputCollectionId&#x60; can optionally be provided.
        /// </summary>
        /// <value>A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for possible output items given by this lootbox. &#x60;outputCollectionAddress&#x60; or &#x60;outputCollectionId&#x60; can optionally be provided.</value>
        [DataMember(Name="outputCollectionAddress", EmitDefaultValue=false)]
        public string OutputCollectionAddress { get; set; }

        /// <summary>
        /// A valid MetaFab collection id that represents the collection for possible output items given by this lootbox. &#x60;outputCollectionAddress&#x60; or &#x60;outputCollectionId&#x60; can optionally be provided.
        /// </summary>
        /// <value>A valid MetaFab collection id that represents the collection for possible output items given by this lootbox. &#x60;outputCollectionAddress&#x60; or &#x60;outputCollectionId&#x60; can optionally be provided.</value>
        [DataMember(Name="outputCollectionId", EmitDefaultValue=false)]
        public string OutputCollectionId { get; set; }

        /// <summary>
        /// An array of item ids from the provided output collection that are possibly given by this lootbox. Randomly selected output items are automatically minted if the lootbox manager contract has the &#x60;minter&#x60; role for the output collection contract. Otherwise, they are transferred from the item balance held by the lootbox manager contract.
        /// </summary>
        /// <value>An array of item ids from the provided output collection that are possibly given by this lootbox. Randomly selected output items are automatically minted if the lootbox manager contract has the &#x60;minter&#x60; role for the output collection contract. Otherwise, they are transferred from the item balance held by the lootbox manager contract.</value>
        [DataMember(Name="outputCollectionItemIds", EmitDefaultValue=false)]
        public List<int> OutputCollectionItemIds { get; set; }

        /// <summary>
        /// An array of amounts for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index.
        /// </summary>
        /// <value>An array of amounts for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index.</value>
        [DataMember(Name="outputCollectionItemAmounts", EmitDefaultValue=false)]
        public List<int> OutputCollectionItemAmounts { get; set; }

        /// <summary>
        /// An array of weights for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Any positive integer for an item&#39;s weight can be provided. The weight for an item relative to the sum of all possible item weights determines the probability that an item will be picked upon a lootbox being opened. Item weights array indices are reflective of the probability weight for a given item id at the same index.
        /// </summary>
        /// <value>An array of weights for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Any positive integer for an item&#39;s weight can be provided. The weight for an item relative to the sum of all possible item weights determines the probability that an item will be picked upon a lootbox being opened. Item weights array indices are reflective of the probability weight for a given item id at the same index.</value>
        [DataMember(Name="outputCollectionItemWeights", EmitDefaultValue=false)]
        public List<int> OutputCollectionItemWeights { get; set; }

        /// <summary>
        /// The number of items randomly selected from the possible output items when this lootbox is open. If you provide a value greater than 1, it is possible for the same item to be selected more than once, giving the opener more than one of that item&#39;s output from the lootbox.
        /// </summary>
        /// <value>The number of items randomly selected from the possible output items when this lootbox is open. If you provide a value greater than 1, it is possible for the same item to be selected more than once, giving the opener more than one of that item&#39;s output from the lootbox.</value>
        [DataMember(Name="outputTotalItems", EmitDefaultValue=false)]
        public int OutputTotalItems { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SetLootboxManagerLootboxRequest {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  InputCollectionAddress: ").Append(InputCollectionAddress).Append("\n");
            sb.Append("  InputCollectionId: ").Append(InputCollectionId).Append("\n");
            sb.Append("  InputCollectionItemIds: ").Append(InputCollectionItemIds).Append("\n");
            sb.Append("  InputCollectionItemAmounts: ").Append(InputCollectionItemAmounts).Append("\n");
            sb.Append("  OutputCollectionAddress: ").Append(OutputCollectionAddress).Append("\n");
            sb.Append("  OutputCollectionId: ").Append(OutputCollectionId).Append("\n");
            sb.Append("  OutputCollectionItemIds: ").Append(OutputCollectionItemIds).Append("\n");
            sb.Append("  OutputCollectionItemAmounts: ").Append(OutputCollectionItemAmounts).Append("\n");
            sb.Append("  OutputCollectionItemWeights: ").Append(OutputCollectionItemWeights).Append("\n");
            sb.Append("  OutputTotalItems: ").Append(OutputTotalItems).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SetLootboxManagerLootboxRequest);
        }

        /// <summary>
        /// Returns true if SetLootboxManagerLootboxRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of SetLootboxManagerLootboxRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SetLootboxManagerLootboxRequest input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.InputCollectionAddress == input.InputCollectionAddress ||
                    (this.InputCollectionAddress != null &&
                    this.InputCollectionAddress.Equals(input.InputCollectionAddress))
                ) && 
                (
                    this.InputCollectionId == input.InputCollectionId ||
                    (this.InputCollectionId != null &&
                    this.InputCollectionId.Equals(input.InputCollectionId))
                ) && 
                (
                    this.InputCollectionItemIds == input.InputCollectionItemIds ||
                    this.InputCollectionItemIds != null &&
                    input.InputCollectionItemIds != null &&
                    this.InputCollectionItemIds.SequenceEqual(input.InputCollectionItemIds)
                ) && 
                (
                    this.InputCollectionItemAmounts == input.InputCollectionItemAmounts ||
                    this.InputCollectionItemAmounts != null &&
                    input.InputCollectionItemAmounts != null &&
                    this.InputCollectionItemAmounts.SequenceEqual(input.InputCollectionItemAmounts)
                ) && 
                (
                    this.OutputCollectionAddress == input.OutputCollectionAddress ||
                    (this.OutputCollectionAddress != null &&
                    this.OutputCollectionAddress.Equals(input.OutputCollectionAddress))
                ) && 
                (
                    this.OutputCollectionId == input.OutputCollectionId ||
                    (this.OutputCollectionId != null &&
                    this.OutputCollectionId.Equals(input.OutputCollectionId))
                ) && 
                (
                    this.OutputCollectionItemIds == input.OutputCollectionItemIds ||
                    this.OutputCollectionItemIds != null &&
                    input.OutputCollectionItemIds != null &&
                    this.OutputCollectionItemIds.SequenceEqual(input.OutputCollectionItemIds)
                ) && 
                (
                    this.OutputCollectionItemAmounts == input.OutputCollectionItemAmounts ||
                    this.OutputCollectionItemAmounts != null &&
                    input.OutputCollectionItemAmounts != null &&
                    this.OutputCollectionItemAmounts.SequenceEqual(input.OutputCollectionItemAmounts)
                ) && 
                (
                    this.OutputCollectionItemWeights == input.OutputCollectionItemWeights ||
                    this.OutputCollectionItemWeights != null &&
                    input.OutputCollectionItemWeights != null &&
                    this.OutputCollectionItemWeights.SequenceEqual(input.OutputCollectionItemWeights)
                ) && 
                (
                    this.OutputTotalItems == input.OutputTotalItems ||
                    (this.OutputTotalItems != null &&
                    this.OutputTotalItems.Equals(input.OutputTotalItems))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.InputCollectionAddress != null)
                    hashCode = hashCode * 59 + this.InputCollectionAddress.GetHashCode();
                if (this.InputCollectionId != null)
                    hashCode = hashCode * 59 + this.InputCollectionId.GetHashCode();
                if (this.InputCollectionItemIds != null)
                    hashCode = hashCode * 59 + this.InputCollectionItemIds.GetHashCode();
                if (this.InputCollectionItemAmounts != null)
                    hashCode = hashCode * 59 + this.InputCollectionItemAmounts.GetHashCode();
                if (this.OutputCollectionAddress != null)
                    hashCode = hashCode * 59 + this.OutputCollectionAddress.GetHashCode();
                if (this.OutputCollectionId != null)
                    hashCode = hashCode * 59 + this.OutputCollectionId.GetHashCode();
                if (this.OutputCollectionItemIds != null)
                    hashCode = hashCode * 59 + this.OutputCollectionItemIds.GetHashCode();
                if (this.OutputCollectionItemAmounts != null)
                    hashCode = hashCode * 59 + this.OutputCollectionItemAmounts.GetHashCode();
                if (this.OutputCollectionItemWeights != null)
                    hashCode = hashCode * 59 + this.OutputCollectionItemWeights.GetHashCode();
                if (this.OutputTotalItems != null)
                    hashCode = hashCode * 59 + this.OutputTotalItems.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
